import aiohttp
import asyncio
from datetime import datetime
from playwright.async_api import async_playwright

COLLECTIONS = [
    "berrybox", "bunnymuffin", "crystalball", "diamondring", "easteregg",
    "electricskull", "eternalcandle", "evileye", "flyingbroom", "genielamp",
    "gingercookie", "hangingstar", "hexpot", "jellybunny", "jesterhat",
    "lovecandle", "madpumpkin", "magicpotion", "partysparkler", "recordplayer",
    "sakuraflower", "skullflower", "snowglobe", "snowmittens", "spicedwine",
    "spyagaric", "starnotepad", "tamagadget", "trappedheart", "winterwreath", "witchhat"
]

PROXY_SERVERS = [
    
]

proxy_stats = {}
proxy_counter = 0


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ Telegram
async def send_telegram_message(message: str):
    bot_token = ""
    chat_id = ""
    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
    params = {
        "chat_id": chat_id,
        "text": message
    }

    conn = aiohttp.TCPConnector(ssl=False)
    async with aiohttp.ClientSession(connector=conn) as session:
        async with session.get(url, params=params) as response:
            if response.status == 200:
                print("‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ Telegram")
            else:
                print(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram: {response.status}")


proxy_stats = {}
proxy_counter = 0


def parse_proxy_url(proxy_url: str) -> dict:
    if not proxy_url.startswith("http://"):
        raise ValueError("Proxy URL –¥–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http://")
    no_http = proxy_url[len("http://"):]
    auth_part, address_part = no_http.split("@")
    username, password = auth_part.split(":")
    return {
        "server": f"http://{address_part}",
        "username": username,
        "password": password
    }


def get_next_proxy():
    global proxy_counter
    if not PROXY_SERVERS:
        return None
    proxy = PROXY_SERVERS[proxy_counter % len(PROXY_SERVERS)]
    proxy_counter += 1
    return proxy


async def parse_collection(page, collection, session):
    url = f"https://fragment.com/gifts/{collection}?attr%5BBackdrop%5D=%5B%22Black%22%5D"
    print(f"\nüîç –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–µ–∫—Ü–∏—é: {collection}...")

    try:
        retry_count = 0
        while retry_count < 3:
            try:
                await page.goto(url, timeout=30000, wait_until="networkidle")
                print(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω URL: {page.url}")
                break
            except Exception as e:
                retry_count += 1
                print(f"‚ùå –ü–æ–ø—ã—Ç–∫–∞ {retry_count} –¥–ª—è {collection} –Ω–µ —É–¥–∞–ª–∞—Å—å: {str(e)}")
                if retry_count == 3:
                    raise
                await asyncio.sleep(1)

        try:
            await page.wait_for_selector("a.tm-grid-item", timeout=30000)
        except Exception as e:
            print(f"‚ö†Ô∏è –°–µ–ª–µ–∫—Ç–æ—Ä 'a.tm-grid-item' –Ω–µ –Ω–∞–π–¥–µ–Ω. –°—Ç—Ä–∞–Ω–∏—Ü–∞:")
            print(await page.content())
            return []

        await page.evaluate("""
            async () => {
                await new Promise((resolve) => {
                    let scrollPosition = 0;
                    const scrollStep = 500;
                    const scrollInterval = setInterval(() => {
                        window.scrollBy(0, scrollStep);
                        scrollPosition += scrollStep;
                        if (scrollPosition >= document.body.scrollHeight) {
                            clearInterval(scrollInterval);
                            setTimeout(resolve, 500);
                        }
                    }, 150);
                });
            }
        """)

        items = await page.query_selector_all("a.tm-grid-item")
        print(f"‚úÖ –ù–∞–π–¥–µ–Ω–æ –∫–∞—Ä—Ç–æ—á–µ–∫ –≤ {collection}: {len(items)}")

        collection_gifts = []
        item_processing_tasks = []

        for item in items:
            task = asyncio.create_task(process_item(item, collection))
            item_processing_tasks.append(task)

            if len(item_processing_tasks) >= 20:
                done, pending = await asyncio.wait(
                    item_processing_tasks,
                    return_when=asyncio.FIRST_COMPLETED
                )
                item_processing_tasks = list(pending)
                for task in done:
                    result = await task
                    if result:
                        collection_gifts.append(result)

        if item_processing_tasks:
            results = await asyncio.gather(*item_processing_tasks)
            collection_gifts.extend([r for r in results if r])

        return collection_gifts

    except Exception as e:
        print(f"üö® –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ {collection}: {str(e)}")
        return []


async def process_item(item, collection):
    try:
        status = await item.query_selector("div.tm-grid-item-status")
        if not status or "For sale" not in await status.inner_text():
            return None

        price_element = await item.query_selector("div.tm-grid-item-value.tm-value.icon-before.icon-ton")
        if not price_element:
            return None

        price_text = (await price_element.inner_text()).replace(",", "").replace(" ", "")
        try:
            price = float(price_text)
        except ValueError:
            return None

        if price >= 17:
            return None

        link = await item.get_attribute("href")
        if not link.startswith("http"):
            link = f"https://fragment.com{link}"

        name_element = await item.query_selector(".item-name")
        name = (await name_element.inner_text()).strip() if name_element else collection.capitalize()

        num_element = await item.query_selector(".item-num")
        if num_element:
            num = (await num_element.inner_text()).strip().replace("#", "")
            full_name = f"{name} #{num}"
        else:
            full_name = name

        print(f"üéÅ –ù–∞–π–¥–µ–Ω: {full_name} –∑–∞ {price} TON")

        return {
            "name": full_name,
            "price": f"{price:.2f} TON",
            "link": link,
            "collection": collection
        }

    except Exception as e:
        print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–∞—Ä—Ç–æ—á–∫–∏ –≤ {collection}: {str(e)}")
        return None


async def worker(browser, collection, session, results):
    proxy_url = get_next_proxy()
    proxy_config = None

    if proxy_url:
        try:
            proxy_config = parse_proxy_url(proxy_url)
            print(f"üßë‚Äçüíª –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ–∫—Å–∏: {proxy_config['server']} —Å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–µ–π")
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–±–æ—Ä–µ –ø—Ä–æ–∫—Å–∏: {e}")
            return

        if proxy_url not in proxy_stats:
            proxy_stats[proxy_url] = {"success": 0, "errors": 0}
    else:
        print(f"üßë‚Äçüíª –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–µ–∑ –ø—Ä–æ–∫—Å–∏")

    context = await browser.new_context(
        proxy=proxy_config,
        viewport={"width": 1920, "height": 1080},
        java_script_enabled=True,
        ignore_https_errors=True,
        bypass_csp=True,
        user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36"
    )

    context.set_default_timeout(15000)
    page = await context.new_page()

    try:
        await page.route("**/*.{png,jpg,jpeg,webp,gif,svg,css,woff2}", lambda route: route.abort())

        gifts = await parse_collection(page, collection, session)
        results.extend(gifts)
        if proxy_url:
            proxy_stats[proxy_url]["success"] += 1
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –≤ worker –¥–ª—è {collection}: {str(e)}")
        if proxy_url:
            proxy_stats[proxy_url]["errors"] += 1
    finally:
        await context.close()


async def parse_black_gifts():
    all_black_gifts = []
    connector = aiohttp.TCPConnector(limit_per_host=15, force_close=True)

    async with async_playwright() as p:
        browser = await p.chromium.launch(
            headless=True,
            args=[
                '--disable-gpu',
                '--disable-dev-shm-usage',
                '--disable-setuid-sandbox',
                '--no-sandbox',
                '--disable-web-security',
                '--disable-features=IsolateOrigins,site-per-process'
            ]
        )

        async with aiohttp.ClientSession(connector=connector) as session:
            semaphore = asyncio.Semaphore(10)
            tasks = []
            results = []

            async def limited_worker(*args):
                async with semaphore:
                    await worker(*args)

            for collection in COLLECTIONS:
                task = asyncio.create_task(limited_worker(browser, collection, session, results))
                tasks.append(task)

            await asyncio.gather(*tasks)
            all_black_gifts = results

    print("\nüìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø—Ä–æ–∫—Å–∏:")
    for proxy, stats in proxy_stats.items():
        print(f"{proxy.split('@')[-1]}: –£—Å–ø–µ—à–Ω–æ {stats['success']}, –û—à–∏–±–æ–∫ {stats['errors']}")

    return all_black_gifts


async def main():
    print("üîÑ –ó–∞–ø—É—Å–∫ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –ø–∞—Ä—Å–µ—Ä–∞...")
    start_time = datetime.now()

    gifts = await parse_black_gifts()

    duration = datetime.now() - start_time
    print(f"\n‚è± –í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {duration.total_seconds():.2f} —Å–µ–∫")
    print(f"‚è± –°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –Ω–∞ –∫–æ–ª–ª–µ–∫—Ü–∏—é: {duration.total_seconds() / len(COLLECTIONS):.2f} —Å–µ–∫")

    if gifts:
        print("\nüéâ –ù–∞–π–¥–µ–Ω–æ –ø–æ–¥–∞—Ä–∫–æ–≤:", len(gifts))
        for gift in gifts[:10]:
            print(f"{gift['name']} | {gift['price']} | {gift['link']}")

        telegram_text = "üéÅ –ù–∞–π–¥–µ–Ω—ã –ø–æ–¥–∞—Ä–∫–∏:\n" + "\n".join(
            f"{gift['name']} ‚Äî {gift['price']}\n{gift['link']}" for gift in gifts[:5]
        )
        await send_telegram_message(telegram_text)

        if len(gifts) > 10:
            print(f"... –∏ –µ—â–µ {len(gifts) - 10}")

        with open("playwright_results.txt", "w", encoding="utf-8") as f:
            for gift in gifts:
                f.write(f"{gift['name']} | {gift['price']} | {gift['link']}\n")
        print("\nüíæ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ playwright_results.txt")
    else:
        print("\n‚ùå –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")


async def repeat_task():
    while True:
        print("üîÑ –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ–≤—Ç–æ—Ä–Ω—É—é –∑–∞–¥–∞—á—É...")
        try:
            await main()  # –ó–∞–ø—É—Å–∫ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –∫–æ–¥–∞
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏: {str(e)}")
            await send_telegram_message(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏: {str(e)}")

        # –ü–∞—É–∑–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ–º (–Ω–∞–ø—Ä–∏–º–µ—Ä, —á–µ—Ä–µ–∑ 1 —á–∞—Å)
        await asyncio.sleep(20)  # 3600 —Å–µ–∫—É–Ω–¥ = 1 —á–∞—Å


if __name__ == "__main__":
    asyncio.run(repeat_task())
